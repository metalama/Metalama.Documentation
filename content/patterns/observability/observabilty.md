---
uid: observability
---

# Observability

The Observable pattern is widely used to bind user interface controls to their underlying data, especially in projects that follow the MVVM architecture. In .NET, the standard interface of the Observable pattern is <xref:System.ComponentModel.INotifyPropertyChanged>. Another common element of the Observable pattern is the `OnPropertyChanged` method, whose name can vary in different MVVM frameworks.

Metalama provides an open-source implementation of the Observable pattern in the `Metalama.Patterns.Observability` package. 

The principal benefits of using  `Metalama.Patterns.Observability` are:

* Support for both automatic and explicitly-implemented properties.
* Support for computed properties that depend on **child objects** -- a common scenario in MVVM architectures,
* Support for computed properties that depend on **methods**.
* Safety: the package reports warnings if a dependency or code construct is not supported.


The principal artifacts in this package are:

* The <xref:Metalama.Patterns.Observability.ObservableAttribute?text=[Observable]> aspect, which auto-magically implements the <xref:System.ComponentModel.INotifyPropertyChanged> interface for the target type.
* The <xref:Metalama.Patterns.Observability.Configuration.ObservabilityExtensions.ConfigureObservability*> extension methods, designed to be called from a fabric.
* The <xref:Metalama.Patterns.Observability.ConstantAttribute?text=[Constant]> attribute, which promises that the output of a method is constant for identical parameters.


## Implementing INotifyPropertyChanged for a class hierarchy

1. Add a reference to the `Metalama.Patterns.Observability` package.
2. Add the <xref:Metalama.Patterns.Observability.ObservableAttribute?text=[Observable]> attribute to each class requiring the <xref:System.ComponentModel.INotifyPropertyChanged> interface. Note that the  <xref:Metalama.Patterns.Observability.ObservableAttribute?text=Observable> aspect is automatically inherited; you don't need to manually add the attribute to derived classes if the aspect has been applied on a base class.
3. Consider making these classes `partial` if you need source code to "see" that these class now implement the  <xref:System.ComponentModel.INotifyPropertyChanged> interface.
3. Check for `LAMA51**` warnings in your code. They draw your attention to situations that are not supported by the <xref:Metalama.Patterns.Observability.ObservableAttribute?text=Observable> aspect, and requires manual handling. This is described in the next session.

Here is an example of the code generated by the <xref:Metalama.Patterns.Observability.ObservableAttribute?text=Observable> aspect for a simple case:

[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/ComputedProperty.cs]


## Understanding and working around limitations

Before transforming a type, the  <xref:Metalama.Patterns.Observability.ObservableAttribute?text=Observable> aspect analyzes the dependencies between different properties in this type; it builds a dependency graph and this graph becomes the input of the source generation algorithm.

As stated in the introduction, the graph analysis understands references to fields, properties, properties of child objects (and recursively), and some methods. When a situation is not supported, the Observable aspect reports a warning.

Here is an example of code where a computed property has a dependency on an unsupported method.

[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/Warning.cs]

Here are different ways to cope with these warnings:

### Ignoring the warning

If you consider the warning to be a false positive, you can skip it using the classic `#pragma disable warning` syntax.

If you want to disable all warnings in a member, you can also use the <xref:Metalama.Patterns.Observability.SuppressObservabilityWarningsAttribute?text=[SuppressObservabilityWarnings]> attribute, which is provided for find-and-replace-all compatibility with PostSharp.

> [!WARNING]
> These warnings mean that a dependency will _not_ be handled by the generated code. Suppressing the warning, of course, has no effect on the generated code.


[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/SuppressObservabilityWarnings.cs]


## Skipping a property

To exclude a property from the change-notification mechanism, use the <xref:Metalama.Patterns.Observability.NotObservableAttribute?text=[NotObservable]> attribute.

In this example, we exclude a property that depends on `DateTime.Now`. Since the value of this property changes every instance, another way of notifying changes should be implemented -- for instance using a timer.

[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/Skipping.cs]

## Marking methods are constant

Calls to methods of different types are supported only if they are known to be _constant_, i.e. if subsequent calls with the exact same arguments are guaranteed to always return the same value.

The following methods are considered _constant_:

* Static methods whose all input arguments are of an _immutable_ type. Immutability is handled using the `Metalama.Patterns.Immutability` patterns. For details, see <xref:immutability>.
* `void` methods without `out` arguments.
* Methods marked as constants using the  <xref:Metalama.Patterns.Observability.ConstantAttribute?text=[Constant]> custom attribute or using a fabric (see below).


### Using the [Constant] attribute

Add the <xref:Metalama.Patterns.Observability.ConstantAttribute?text=[Constant]> custom attribute to a method to represent that

[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/Constant.cs]

### Using a fabric

If you want to mark many methods as constant, it may be more convenient to use a fabric instead of adding the `[Constant]` attribute to each of them.

[!metalama-test ~/code/Metalama.Documentation.SampleCode.Observability/Constant_Fabric.cs]

## Working with MVVM frameworks

 Instead of `OnPropertyChanged` methods, Other accepted method names are `NotifyOfPropertyChange` and `RaisePropertyChanged`.

## Limitations and workarounds

### Limitations

- method calls: only static methods of with primitive arguments
- other methods cause a warning to be reported
- two mechanisms to work around the warning: `#pragma` and `[SuppressObservabilityWarnings]`
- Mark methods as constants: `[Constant]` or fabric method