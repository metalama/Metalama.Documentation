---
uid: benefits-over-postsharp
summary: "Metalama offers benefits over PostSharp including higher runtime performance, broader platform support, visibility of declarations introduced by aspects from the source code, and real-time feedback while editing code."
---

# Benefits of Metalama over PostSharp

## Higher runtime performance

In Metalama, aspects are _inlined_ into your source code. Aspects provide code templates that are expanded into your source code at compile time.

By contrast, PostSharp employs run-time objects that are _invoked_ from your source code. To pass the execution context, such as the current instance and method arguments, from the source code to the aspect, PostSharp utilizes heap-allocated objects like `MethodExecutionArgs`. This implementation strategy incurs a performance overhead, which Metalama successfully avoids.

Thanks to the [T# templating technology](xref:templates), it is significantly easier in Metalama to construct high-performance aspects. Additionally, understanding the performance characteristics of an aspect is simplified as the generated code is immediately readable by a human.

## Broader platform support

Metalama is a purely compiler-based technology, supporting any platform compatible with .NET Standard 2.0.

In contrast, PostSharp is a post-compiler. It is a .NET Framework or .NET Core process that loads the _whole_ assembly generated by the compiler into the runtime and then executes aspects, representing the code model with the `System.Reflection` namespace.

The necessity for PostSharp to load assemblies into the CLR meant that it could not process projects incompatible with .NET Framework or .NET Core, and with the processor of the compiler itself. This limitation is not present in Metalama.

So, how does Metalama execute aspects without loading the assembly into the compiler process? Metalama divides the user code into two subsets: the _compile-time_ code and the _run-time_ code. Metalama compiles the compile-time code separately as an assembly targeting .NET Standard 2.0, and loads this assembly into the compiler process. The user code, which may be written for any platform, is never executed in the compiler process.

This new architecture makes Metalama future-proof: Metalama will support any platform that can be coded in C# because Metalama is essentially a compiler or an IDE plug-in, both of which are maintained by Microsoft.

## Declarations introduced by aspects are visible from the source code

In Metalama, when an aspect introduces a declaration into a type, this new declaration can be used in your source code as if it were part of the source code itself. This is possible because Metalama operates within the compiler or the IDE.

In PostSharp, declarations introduced by aspects could not be used in your source code. The reason for this limitation is that PostSharp, as a post-compiler, operates _after_ the compiler. Therefore, any changes made by PostSharp are not visible from any upstream process, such as the compiler or the IDE.

## Real-time feedback while editing code

With PostSharp, you had to build your projects to receive the warnings and errors provided by the aspects or to update the data shown by PostSharp Tools in Visual Studio.

With Metalama, you receive feedback within seconds because your projects are always verified in real-time by the IDEâ€”and Metalama integrates with the IDE.

