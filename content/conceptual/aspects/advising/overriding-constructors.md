---
uid: overriding-constructors
---

# Overriding constructors

Overriding constructors is an advanced technique with only a few limited use cases. Before opting for this approach, we recommend considering other alternatives.

## When to override constructors

We recommend overriding constructors only if none of the following approaches work for your case.

| Approach | Scenario |
|----------|-----------|
| <xref:initializers> | You can add an initializer to an object or type constructor when you want to call an initialization statement before any source code, typically to initialize the type or object. The drawback of this approach is that it does not support T# templates. |
| <xref:introducing-constructor-parameters> | When you want to introduce a parameter, typically a dependency, and pull it from constructors of derived types. |


## How to override a constructor

Overriding a constructor works in a similar way to overriding a method.

Your aspect must implement the <xref:Metalama.Framework.Aspects.IAspect`1.BuildAspect*> method and invoke the <xref:Metalama.Framework.Advising.IAdviceFactory.Override(Metalama.Framework.Code.IConstructor,System.String,System.Object,System.Object)?text=builder.Advice.Override> method.

To invoke the original implementation, call <xref:Metalama.Framework.Aspects.meta.Proceed?text=meta.Proceed>. Note that, unlike methods, you can <xref:Metalama.Framework.Aspects.meta.Proceed?text=meta.Proceed> only once when overriding a constructor.

> [!WARNING]
> Any code generated by the template is always applied _after_ the call to the next constructor using the `: base(...)` or `: this(...)` construct.


## Example: logging

The following example illustrates how overriding constructors works. The `LogConstructors` aspect overrides all constructors of a class and encloses their implementation with logging statements. We apply the aspect to a class that has two chained constructors. The program output shows a confusing log where it seems that both constructors have been called in sequence rather than being nested. This paradox is explained because the call to the next constructor happens outside of the code modified by the template.

[!metalama-test ~/code/Metalama.Documentation.SampleCode.AspectFramework/OverrideConstructor.cs name="Overriding a constructor"]
